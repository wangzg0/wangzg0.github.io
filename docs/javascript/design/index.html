<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="王志刚的博客 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="王志刚的博客 Blog Atom Feed"><title data-react-helmet="true">设计模式 | 王志刚的博客</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="设计模式 | 王志刚的博客"><meta data-react-helmet="true" name="description" content="在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。 ——维基百科"><meta data-react-helmet="true" property="og:description" content="在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。 ——维基百科"><meta data-react-helmet="true" property="og:url" content="https://wangzg0.github.io/docs/javascript/design"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://wangzg0.github.io/docs/javascript/design"><link rel="stylesheet" href="/styles.c025bdb8.css">
<link rel="preload" href="/styles.2e3526c0.js" as="script">
<link rel="preload" href="/runtime~main.b2ec19b9.js" as="script">
<link rel="preload" href="/main.47aef0ab.js" as="script">
<link rel="preload" href="/1.043bfae5.js" as="script">
<link rel="preload" href="/2.43a1a627.js" as="script">
<link rel="preload" href="/33.bd4e36e7.js" as="script">
<link rel="preload" href="/34.9a26ead1.js" as="script">
<link rel="preload" href="/f976f453.2cdaa488.js" as="script">
<link rel="preload" href="/17896441.e2a3b6ae.js" as="script">
<link rel="preload" href="/101703e8.5bca6b43.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><strong class="navbar__title">  主页</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/javascript/es6">笔记</a><a class="navbar__item navbar__link" href="/blog">知识库</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/wangzg0" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Github</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><strong class="navbar__title">  主页</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/javascript/es6">笔记</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">知识库</a></li><li class="menu__list-item"><a href="https://github.com/wangzg0" target="_blank" rel="noopener noreferrer" class="menu__link">Github</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_vMrn"><div class="docSidebarContainer_3Ak5" role="complementary"><div class="sidebar_3gvy"><div class="menu menu--responsive thin-scrollbar menu_1yIk"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_1CUI" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">JavaScript</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/javascript/es6">ESNext 新特性</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/javascript/async">js异步编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/javascript/func">函数式编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/javascript/v8">浏览器 V8 引擎 GC 算法原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/javascript/moment">使用moment格式化时间</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/javascript/webpack">使用webpack</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/javascript/design">设计模式</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">TypeScript</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/typescript/ts">Typescript使用总结</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">HTML5</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/html5/qa">浏览器常见问题</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/html5/css">CSS</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/html5/scroll">自定义滚动条样式</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/html5/bfc">BFC理解与应用</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">工作中的问题</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/worker/worker_reg_exp">开发中常用的正则表单校验</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">框架学习</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/frame/vue2">vue2 笔记</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/frame/vue3">vue3.x学习</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">sql</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/sql/tb_action">数据库操作</a></li></ul></li></ul></div><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_2WRA"><svg width="20" height="20" role="img" class="collapseSidebarButtonIcon_CoMu"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div><main class="docMainContainer_2iGs"><div class="container padding-vert--lg docItemWrapper_1bxp"><div class="row"><div class="col docItemCol_U38p"><div class="docItemContainer_a7m4"><article><header><h1 class="docTitle_Oumm">设计模式</h1></header><div class="markdown"><blockquote><p>在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。 ——维基百科</p></blockquote><p>最近拜读了淘系前端大神修言大佬的《JavaScript 设计模式核⼼原理与应⽤实践》，让我受益匪浅，一直沉浸在业务上重复造轮子的调包虾，每天感觉工作满满，但是未曾感觉自己在进步，此文参照该文章进行了二次消化并记录下来，帮助自己和有同样情况的同学不断加深对设计模式的理解，并运用到日常工作中</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="创建型---构造器模式"></a>创建型 - 构造器模式<a class="hash-link" href="#创建型---构造器模式" title="Direct link to heading">#</a></h3><p>在<code>JavaScript</code>中，我们使用构造函数去初始化对象，就是应用了构造器模式。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 假如你是Riot公司的一名程序员，领导让你使用js重新开发lol这款游戏</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 首先创建一名英雄到系统内</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const Aixi = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  name: &#x27;艾希&#x27;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  title: &#x27;寒冰射手&#x27;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  role: &#x27;射手&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 创建第二名英雄</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const Zhaoxin = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  name: &#x27;赵信&#x27;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  title: &#x27;德邦总管&#x27;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  role: &#x27;战士&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 想想还有100多名英雄没创建呢，要加班到深夜呀，于是写个构造函数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function Hero(name, title, role) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.name = name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.title = title;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.role = role;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 创建英雄就new一下就搞定了</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const Jiakesi = new Hero(&#x27;贾克斯&#x27;, &#x27;武器大师&#x27;, &#x27;战士&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const Yidashi = new Hero(&#x27;易大师&#x27;, &#x27;无极剑圣&#x27;, &#x27;刺客&#x27;);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>构造器将<code>name、title、role</code>赋值给对象的过程封装，确保了每个对象都具备这些属性，确保了共性的不变，同时将 <code>name、title、role</code>各自的取值操作开放，确保了个性的灵活</p><p>如果在使用构造器模式的时候，我们本质上是去抽象了每个对象实例的变与不变。那么使用工厂模式时，我们要做的就是去抽象不同构造函数（类）之间的变与不变</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="创建型---简单工厂模式"></a>创建型 - 简单工厂模式<a class="hash-link" href="#创建型---简单工厂模式" title="Direct link to heading">#</a></h3><p>产品经理提到不同的英雄类型有不同的特性，比如射手的普攻距离是 <code>500</code> 码，战士是 <code>125</code> 码</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 为了解决上述问题，把Hero拆成两个类别Shorter和Longer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function Longer(name, title, role) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.name = name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.title = title;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.role = &#x27;射手&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.attackDistance = 500;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function Shorter(name, title, role) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.name = name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.title = title;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.role = &#x27;战士&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.attackDistance = 125;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 通过一个函数判断英雄角色来使用不同构造器</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function handleRole(name, title, role) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  switch (role) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    case: &#x27;射手&#x27;:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return new Longer(name, title, role);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    case: &#x27;战士&#x27;:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return new Shorter(name, title, role);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 我们可以这样创建了</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const Jiakesi = new handleRole(&#x27;贾克斯&#x27;, &#x27;武器大师&#x27;, &#x27;战士&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const Aixi = new handleRole(&#x27;艾希&#x27;, &#x27;寒冰射手&#x27;, &#x27;射手&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 为了将共性封装地更彻底，也为了将共性与个性分离地更彻底，我可以再把他们整合回Hero</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function Hero(name, title, role, attackDistance) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.name = name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.title = title;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.role = role;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.attackDistance = attackDistance;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 然后写一个生成英雄的函数，因为英雄们就像是从流水线上生产的产品，所以给这个函数取名为“英雄工厂”</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function HeroFactory(name, title, role) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  let attackDistance;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  switch (role) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    case &quot;射手&quot;:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      attackDistance = 500;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    case &quot;刺客&quot;:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      attackDistance = 125;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return new Hero(name, title, role, speciality);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const Jiakesi = new HeroFactory(&#x27;贾克斯&#x27;, &#x27;武器大师&#x27;, &#x27;战士&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const Aixi = new HeroFactory(&#x27;艾希&#x27;, &#x27;寒冰射手&#x27;, &#x27;射手&#x27;);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="创建型---抽象工厂模式"></a>创建型 - 抽象工厂模式<a class="hash-link" href="#创建型---抽象工厂模式" title="Direct link to heading">#</a></h3><p>抽象工厂模式的定义，是围绕一个超级工厂创建其他工厂，抽象工厂是佐证“开放封闭原则”的良好素材</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 接下来就是开一把游戏了，建立一种游戏模式需要游戏类型、地图、游戏机制</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function Mode(type, map, mechanism) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.type = type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.map = map;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.mechanism = mechanism;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 模仿英雄工厂创建有个游戏工厂</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function GameFactory(type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  let map;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  let mechanism;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  switch (type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    case &#x27;普通匹配&#x27;:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      map = &#x27;普通模式&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      mechanism = &#x27;普通机制&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    case &#x27;克隆模式&#x27;:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      map = &#x27;克隆大作战&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      mechanism = &#x27;克隆机制&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    default:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      map = &#x27;&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      mechanism = &#x27;&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      brreak;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return new Mode(type, map, mechanism);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 创建一个克隆模式</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const cloneMode = GameFactory(&#x27;克隆模式&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">//  一段时间后，产品经理觉得克隆模式节奏太慢，决定在游戏机制中把技能冷却时间缩短40%；</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 这时你要去GameFactory函数内修改克隆模式里的mechanism逻辑；</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 没过多久，需要在克隆模式地图中加入一条哥斯拉增加游戏难度，这时还要修改对应的map逻辑;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 几次改写导致GameFactory愈发混乱、臃肿，难以维护</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 这时候，可以把地图map和游戏机制mechanism抽象出来</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function xiaguMap() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 召唤师峡谷地图逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function cloneMap() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 克隆大作战地图逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 地图工厂</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function MapFactory(type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  switch (type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    case &#x27;召唤师峡谷&#x27;:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return new xiaguMap();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    case &#x27;克隆大作战&#x27;:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return new cloneMap()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function currentMechanism() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 普通模式游戏机制逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function cloneMechanism() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 克隆游戏机制逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 游戏机制工厂</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function MechanismFactory(type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  switch (type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    case &#x27;普通模式&#x27;:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return new currentMechanism();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    case &#x27;克隆机制&#x27;:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return new cloneMechanism()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function GameFactory(type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  let map;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  let mechanism;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  switch (type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    case &#x27;普通匹配&#x27;:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      map = MapFactory(&#x27;召唤师峡谷&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      mechanism = MechanismFactory(&#x27;普通模式&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    case &#x27;克隆模式&#x27;:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      map = MapFactory(&#x27;克隆大作战&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      mechanism = MechanismFactory(&#x27;克隆机制&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      break;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    default:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      map = &#x27;&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      mechanism = &#x27;&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      brreak;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return new Mode(type, map, mechanism);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 好景不长，产品经理觉得新年要新出一个临时模式，叫飞升模式，地图用新年雪人地图，游戏机制全改动;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 这时我们不得不修改GameFactory中的逻辑，新增type属性，再新写一套逻辑进去，而且游新年结束后，还要改回去;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 这种对“已建工厂”的修改违反了开放封闭原则（类、模块、函数可以扩展，但是不可修改的原则）;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 如何避免直接修改工厂内部的逻辑呢？</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 郁闷的你中午吃完饭出去跟同事侃大山时从Java那哥们讲的的抽象类中获取了灵感，决定写“抽象工厂”和”抽象产品</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class GameFactory {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  createMap() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    throw new Error(&quot;抽象工厂方法不允许直接调用，你需要将我覆写！&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  createMechanism() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    throw new Error(&quot;抽象工厂方法不允许直接调用，你需要将我覆写！&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Map {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  init() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    throw new Error(&quot;抽象工厂方法不允许直接调用，你需要将我覆写！&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Mechanism {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  init() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    throw new Error(&quot;抽象工厂方法不允许直接调用，你需要将我覆写！&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 新建一个限定活动飞升模式</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class FlyMap extends Map {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  init() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 飞升模式逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 飞升模式机制</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class FlyMechansims extends Mechansims {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  init() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 飞升模式机制</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 飞升模式</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class FlyModeFactory extends GameFactory {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  createMap() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return new FlyMap();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  createMechansims() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return new FlyMechansims();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 新增一个飞升模式</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const FlyMode = new FlyModeFactory();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 总结:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// GameFactory，抽象工厂：声明最终目标产品的共性、规范</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// FlyModeFactory，具体工厂：继承自抽象工厂，实现了抽象工厂里声明的那些方法，用于实例化最终目标产品</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Map，Mechanism，抽象产品：具体工厂里实现的方法，会依赖一些产品，抽象产品声明这些产品的共性、规范</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// FlyMap，FlyMechansims，具体产品：见抽象产品</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="创建型---单例模式"></a>创建型 - 单例模式<a class="hash-link" href="#创建型---单例模式" title="Direct link to heading">#</a></h3><p>单例模式想要做到的是，不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 游戏中玩家在看tab面板能看到每个人的出装，使用`es6 class`创建单例模式</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class GameInfo {};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const player1 = new GameInfo();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const player2 = new GameInfo();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 玩家之间不能共用信息</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(player1 === player2) // false</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 通过GameInfo.instance获取同一对象</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class GameInfo {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  static getInstance() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(!GameInfo.instance) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      GameInfo.instance = new GameInfo();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return GameInfo.instance;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const player3 = GameInfo.getInstance();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const player4 = GameInfo.getInstance();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 可以共享信息</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(player3 === player4) // true</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// vuex用到了单例模式</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 闭包实现</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">SingleDog.getInstance = (function() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 定义自由变量instance，模拟私有变量</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  let instance = null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return function() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 判断自由变量是否为null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(!instance) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      // 如果为null则new出唯一实例</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      instance = new SingleDog()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return instance</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">})()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>我的理解单例模式就是共享一块内存，new 一个实例不会再开辟新内存。</p><p>面试题：实现一个全局唯一弹窗</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 闭包</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">let Modal = (function() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  let modal = null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return function() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!modal) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      modal = document.createElement(&quot;div&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      modal.innerHTML = &quot;this is modal!&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      modal.style.display = &quot;none&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      modal.id = &quot;modal&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      document.body.appendChild(modal);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return modal;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">})();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">document.getElementById(&quot;open&quot;).addEventListener(&quot;click&quot;, () =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  let modal = new Modal();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  modal.style.display = &quot;block&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">document.getElementById(&quot;close&quot;).addEventListener(&quot;click&quot;, () =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  let modal = new Modal();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  modal.style.display = &quot;none&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// class类</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Modal {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  constructor() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.dom = null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!Modal.instance) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      this.dom = document.createElement(&quot;div&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      this.dom.innerHTML = &quot;this is modal&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      this.dom.id = &quot;modal&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      this.dom.style.display = &quot;none&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      this.dom.show = this.show.bind(this);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      this.dom.hide = this.hide.bind(this);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      document.body.appendChild(this.dom);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      Modal.instance = this.dom;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return Modal.instance;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  show() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.dom.style.display = &quot;block&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  hide() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.dom.style.display = &quot;none&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const btnShow = document.getElementById(&quot;open&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const btnHide = document.getElementById(&quot;close&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">btnShow.addEventListener(&quot;click&quot;, () =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  let modal = new Modal();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  modal.show();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">btnHide.addEventListener(&quot;click&quot;, () =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  let modal = new Modal();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  modal.hide();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="创建型---原型模式"></a>创建型 - 原型模式<a class="hash-link" href="#创建型---原型模式" title="Direct link to heading">#</a></h3><p>原型模式不仅是一种设计模式，它还是一种编程范式（programming paradigm），是 JavaScript 面向对象系统实现的根基。</p><p>原型编程范式的核心思想就是利用实例来描述对象，用实例作为定义对象和继承的基础。在 JavaScript 中，原型编程范式的体现就是基于原型链的继承。这其中，对原型、原型链的理解是关键。</p><blockquote><p>ECMAScript 2015 中引入的 JavaScript 类实质上是 JavaScript 现有的基于原型的继承的语法糖。类语法不会为 JavaScript 引入新的面向对象的继承模型。 ——MDN</p></blockquote><p>在 JavaScript 中，每个构造函数都拥有一个 prototype 属性，它指向构造函数的原型对象，这个原型对象中有一个 construtor 属性指回构造函数；每个实例都有一个<strong>proto</strong>属性，当我们使用构造函数去创建实例时，实例的<strong>proto</strong>属性就会指向构造函数的原型对象。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 创建一个Dog构造函数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function Dog(name, age) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.name = name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.age = age</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Dog.prototype.eat = function() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(&#x27;肉骨头真好吃&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 使用Dog构造函数创建dog实例</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const dog = new Dog(&#x27;旺财&#x27;, 3)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>实现一个深拷贝</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 方法一，缺点是没法拷贝函数和正则</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function deepClone(obj) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  let str = JSON.stringify(obj);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return JSON.parse(str);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 方法二，使用递归，原理层面实现深拷贝</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function deepClone(obj) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 如果是值类型或 null，则直接return</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if(typeof obj !== &#x27;object&#x27; || obj === null) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return obj;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 定义结果对象</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  let copy = {};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 如果对象是数组，则定义结果数组</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if(obj.constructor === Array) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    copy = [];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 遍历对象的key</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for(let key in obj) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 如果key是对象的自有属性</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(obj.hasOwnProperty(key)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      // 递归调用深拷贝方法</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      copy[key] = deepClone(obj[key]);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return copy;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="结构型---装饰器模式"></a>结构型 - 装饰器模式<a class="hash-link" href="#结构型---装饰器模式" title="Direct link to heading">#</a></h3><p>装饰器模式，又名装饰者模式。它的定义是“在不改变原对象的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求”。</p><p>在 ES7 中，通过一个@语法糖轻松地给一个类装上装饰器</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">function classDecorator(target) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    target.hasDecorator = true</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return target</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 将装饰器“安装”到Button类上</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@classDecorator</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Button {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // Button类的相关逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>React 中的装饰器：HOC</p><blockquote><p>高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。</p></blockquote><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">import React, { Component } from &#x27;react&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const BorderHoc = WrappedComponent =&gt; class extends Component {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  render() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return &lt;div style={{ border: &#x27;solid 1px red&#x27; }}&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &lt;WrappedComponent /&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &lt;/div&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">export default borderHoc</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>装饰目标组件</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">import React, { Component } from &#x27;react&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import BorderHoc from &#x27;./BorderHoc&#x27;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 用BorderHoc装饰目标组件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@BorderHoc</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class TargetComponent extends React.Component {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  render() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 目标组件具体的业务逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// export出去的其实是一个被包裹后的组件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">export default TargetComponent</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="结构型---适配器模式"></a>结构型 - 适配器模式<a class="hash-link" href="#结构型---适配器模式" title="Direct link to heading">#</a></h3><blockquote><p>适配器模式通过把一个类的接口变换成客户端所期待的另一种接口，可以帮我们解决不兼容的问题。不影响现有实现方式，兼容调用旧接口的代码</p></blockquote><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 你写了个新的攻击特效</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function newSpecial(params) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 业务逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 旧的攻击特效</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function oldSpecial(params) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 业务逻辑</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 产品经理让你升级一下，替换掉旧的攻击特效，于是写了个适配器</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function Apatar(params) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  newSpecial(params);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function oldSpecial(params) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Apatar(params);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 适配器类似于转换器, 类似一种可以给安卓和苹果系统充电的手机转换接头。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="结构型---代理模式"></a>结构型 - 代理模式<a class="hash-link" href="#结构型---代理模式" title="Direct link to heading">#</a></h3><p>代理模式，式如其名——在某些情况下，出于种种考虑/限制，一个对象不能直接访问另一个对象，需要一个第三者（代理）牵线搭桥从而间接达到访问目的，这样的模式就是代理模式。</p><blockquote><p>最常见的四种代理类型：事件代理、虚拟代理、缓存代理和保护代理</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="事件代理"></a>事件代理<a class="hash-link" href="#事件代理" title="Direct link to heading">#</a></h4><p>其他三种模式参照修言大佬的掘金小册中有详细介绍。时间代理可能是代理模式最常见的一种应用方式，它的场景是一个父元素下有多个子元素，像这样：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;!DOCTYPE html&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;html lang=&quot;en&quot;&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;head&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &lt;title&gt;事件代理&lt;/title&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;/head&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;body&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &lt;div id=&quot;father&quot;&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &lt;a href=&quot;#&quot;&gt;链接1号&lt;/a&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &lt;a href=&quot;#&quot;&gt;链接2号&lt;/a&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &lt;a href=&quot;#&quot;&gt;链接3号&lt;/a&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &lt;a href=&quot;#&quot;&gt;链接4号&lt;/a&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &lt;a href=&quot;#&quot;&gt;链接5号&lt;/a&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &lt;a href=&quot;#&quot;&gt;链接6号&lt;/a&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  &lt;/div&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;/body&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;/html&gt;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>我们现在的需求是，希望鼠标点击每个 a 标签，都可以弹出“我是 xxx”这样的提示。比如点击第一个 a 标签，弹出“我是链接 1 号”这样的提示。这意味着我们至少要安装 6 个监听函数给 6 个不同的的元素(一般我们会用循环，代码如下所示），如果我们的 a 标签进一步增多，那么性能的开销会更大。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 假如不用代理模式，我们将循环安装监听函数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const aNodes = document.getElementById(&#x27;father&#x27;).getElementsByTagName(&#x27;a&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const aLength = aNodes.length</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for(let i=0;i&lt;aLength;i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    aNodes[i].addEventListener(&#x27;click&#x27;, function(e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        e.preventDefault()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        alert(`我是${aNodes[i].innerText}`)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    })</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 考虑到事件本身具有“冒泡”的特性，当我们点击 a 元素时，点击事件会“冒泡”到父元素 div 上，从而被监听到。它可以很大程度上提高我们代码的性能。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 获取父元素</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const father = document.getElementById(&#x27;father&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 给父元素安装一次监听函数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">father.addEventListener(&#x27;click&#x27;, function(e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 识别是否是目标子元素</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(e.target.tagName === &#x27;A&#x27;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        // 以下是监听函数的函数体</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        e.preventDefault()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        alert(`我是${e.target.innerText}`)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} )</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="行为型---策略模式"></a>行为型 - 策略模式<a class="hash-link" href="#行为型---策略模式" title="Direct link to heading">#</a></h3><blockquote><p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p></blockquote><p>终于到了我最喜欢的模式了，这个模式非常实用，在写业务逻辑中经常遇到。<strong>同时坚持开放封闭改造，对扩展开放，对修改封闭</strong></p><p>修言大神给出的经典案例《询价策略》
需求描述:
当价格类型为“预售价”时，满 100 - 20，不满 100 打 9 折</p><p>当价格类型为“大促价”时，满 100 - 30，不满 100 打 8 折</p><p>当价格类型为“返场价”时，满 200 - 50，不叠加</p><p>当价格类型为“尝鲜价”时，直接打 5 折</p><p>他首先将四种价格做了标签化：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">预售价 - pre</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">大促价 - onSale</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">返场价 - back</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">尝鲜价 - fresh</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>使用 if-else ，轻松搞定</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 询价方法，接受价格标签和原价为入参</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function askPrice(tag, originPrice) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 处理预热价</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if(tag === &#x27;pre&#x27;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(originPrice &gt;= 100) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return originPrice - 20</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return originPrice * 0.9</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 处理大促价</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if(tag === &#x27;onSale&#x27;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(originPrice &gt;= 100) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return originPrice - 30</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return originPrice * 0.8</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 处理返场价</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if(tag === &#x27;back&#x27;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(originPrice &gt;= 200) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return originPrice - 50</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return originPrice</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 处理尝鲜价</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if(tag === &#x27;fresh&#x27;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     return originPrice * 0.5</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>缺点： 1.违背了“单一功能”原则。一个 function 里面，它竟然处理了四坨逻辑。 2.违背了“开放封闭”原则。假如增加一个满 100 - 50 的“新人价”怎么办？他只能继续 if-else,由于改动了询价函数，需测试重新回归测试。</p><p>解决办法：使用对象映射，同时遵循单一功能和开放封闭原则</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 定义一个询价处理器对象</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const priceProcessor = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  pre(originPrice) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (originPrice &gt;= 100) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return originPrice - 20;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return originPrice * 0.9;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  onSale(originPrice) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (originPrice &gt;= 100) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return originPrice - 30;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return originPrice * 0.8;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  back(originPrice) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (originPrice &gt;= 200) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return originPrice - 50;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return originPrice;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  fresh(originPrice) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return originPrice * 0.5;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 当我们想使用其中某个询价算法的时候：通过标签名去定位就好了</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 询价函数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function askPrice(tag, originPrice) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return priceProcessor[tag](originPrice)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>假如新增一个条件 新人满 100 返 50</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">priceProcessor.newUser = function (originPrice) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (originPrice &gt;= 100) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return originPrice - 50;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return originPrice;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="行为型---状态模式"></a>行为型 - 状态模式<a class="hash-link" href="#行为型---状态模式" title="Direct link to heading">#</a></h3><p>状态模式和策略模式相似，但状态模式强调了类的概念</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 即把处理过程放在处理对象本身中</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class CoffeeMaker {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  constructor() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.state = &quot;init&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.stock = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      coffee: 500,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      milk: 200,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  changeState(state) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.state = state;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.changeStateProcessor[state]();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  changeStateProcessor = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    that: this,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    coffee() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      console.log(&quot;咖啡机现在的咖啡存储量是:&quot;, this.that.stock.coffee);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      console.log(&quot;我只吐黑咖啡&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    latte() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      this.coffee();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      console.log(&quot;咖啡机现在的咖啡存储量是:&quot;, this.that.stock.milk);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      console.log(&quot;加点奶&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    vanillaLatte() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      this.latte();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      console.log(&quot;再加香草糖浆&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    mocha() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      this.latte();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      console.log(&quot;再加巧克力&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 测试一下</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const coffeeMaker = new CoffeeMaker();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">coffeeMaker.changeState(&quot;latte&quot;);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="行为型---观察者模式"></a>行为型 - 观察者模式<a class="hash-link" href="#行为型---观察者模式" title="Direct link to heading">#</a></h3><blockquote><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</p></blockquote><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 观察者订阅发布者，发布者能群通知观察者们</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Publisher {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  constructor() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.observers = [];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  addObserver(observer) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.observers.push(observer);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  removeObserver(observer) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.observers.forEach((item, index) =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      if (item === observer) this.observers.splice(index, 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  notifyObersers() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.observers.forEach((item) =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      item.update(this);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Observer {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  update(publisher) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 更新操作</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 在上面两个类中扩展出具体的类, 游戏中所有玩家设有提醒机制，如大龙死亡通知所有玩家</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class DragonPublisher extends Publisher {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  constructor() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    super();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.state = null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.observers = [];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  getState() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return this.state;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  setState(state) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.state = state;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.notifyObersers();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class PlayerObserver extends Observer {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  constructor(id) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    super();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.id = id;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.state = null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  update(publisher) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.state = publisher.getState();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.remind();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  remind() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(`接收信息 ${this.state}，巴拉巴拉`);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 测试一下</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const Dragon = new DragonPublisher();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const player1 = new PlayerObserver(&quot;#01&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">const player2 = new PlayerObserver(&quot;#02&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Dragon.addObserver(player1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Dragon.addObserver(player2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Dragon.setState(&quot;大龙已被击杀&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="行为型---发布订阅模式"></a>行为型 - 发布——订阅模式<a class="hash-link" href="#行为型---发布订阅模式" title="Direct link to heading">#</a></h3><p>观察者模式：发布者直接接触订阅者；发布——订阅模式：发布者和订阅者通过中间平台间接接触, 发布者无法感知订阅者</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class EventEmitter {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  constructor() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.handlers = {};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 注册事件监听器</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  on(event, callback) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!this.handlers[event]) this.handlers[event] = [];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.handlers[event].push(callback);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 移除某个事件回调队列里的指定回调函数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  off(event, callback) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    const callbacks = this.handlers[event],</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      index = callbacks.indexOf(callback);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (index !== -1) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      callbacks.splice(index, 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 触发目标事件</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  emit(event, ...params) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (this.handlers[event]) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      this.handlers[event].forEach((callback) =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        callback(...params);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 为事件注册单次监听器</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  once(event, callback) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 对回调函数进行包装，使其执行完毕自动被移除</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    const wrapper = (...params) =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      callback(...params);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      this.off(event, wrapper);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.on(event, wrapper);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>参考文档：掘金小册-<a href="https://juejin.im/book/5c70fc83518825428d7f9dfb/section/5c70fc845188256282697b96" target="_blank" rel="noopener noreferrer">《JavaScript 设计模式核⼼原理与应⽤实践》-修言</a></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/facebook/docusaurus/edit/master/website/docs/javascript/design.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/javascript/webpack"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 使用webpack</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/typescript/ts"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Typescript使用总结 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#创建型---构造器模式" class="table-of-contents__link">创建型 - 构造器模式</a></li><li><a href="#创建型---简单工厂模式" class="table-of-contents__link">创建型 - 简单工厂模式</a></li><li><a href="#创建型---抽象工厂模式" class="table-of-contents__link">创建型 - 抽象工厂模式</a></li><li><a href="#创建型---单例模式" class="table-of-contents__link">创建型 - 单例模式</a></li><li><a href="#创建型---原型模式" class="table-of-contents__link">创建型 - 原型模式</a></li><li><a href="#结构型---装饰器模式" class="table-of-contents__link">结构型 - 装饰器模式</a></li><li><a href="#结构型---适配器模式" class="table-of-contents__link">结构型 - 适配器模式</a></li><li><a href="#结构型---代理模式" class="table-of-contents__link">结构型 - 代理模式</a></li><li><a href="#行为型---策略模式" class="table-of-contents__link">行为型 - 策略模式</a></li><li><a href="#行为型---状态模式" class="table-of-contents__link">行为型 - 状态模式</a></li><li><a href="#行为型---观察者模式" class="table-of-contents__link">行为型 - 观察者模式</a></li><li><a href="#行为型---发布订阅模式" class="table-of-contents__link">行为型 - 发布——订阅模式</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.2e3526c0.js"></script>
<script src="/runtime~main.b2ec19b9.js"></script>
<script src="/main.47aef0ab.js"></script>
<script src="/1.043bfae5.js"></script>
<script src="/2.43a1a627.js"></script>
<script src="/33.bd4e36e7.js"></script>
<script src="/34.9a26ead1.js"></script>
<script src="/f976f453.2cdaa488.js"></script>
<script src="/17896441.e2a3b6ae.js"></script>
<script src="/101703e8.5bca6b43.js"></script>
</body>
</html>